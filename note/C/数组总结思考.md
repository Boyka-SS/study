- ```c
  int a;//单一的值
  int b[10];//一些值的集合
  ```

  下标和数组名一起使用，用于`标识该集合中某个特定的值`。每个特定的值都是一个标量。

  `数组名的值是一个指针常量，也就是数组第一个元素的地址，类型取决于数组元素的类型`。数组名不同于指针，是指针常量，不可随意修改指针指向，`数组名不可以被赋值`。只有在两种情况下，数组名不用指针常量来表示：

  1. 数组名作为`sizeof操作符`的操作数：

     sizeof返回整个数组的长度，而不是指向数组的指针的长度

  2. 作为`&操作符`的操作数：

     取一个数组名的地址所产生的是一个指向数组的指针，而不是一个指向某个指针常量值的指针

- `不能使用赋值符把一个数组的所有元素复制到另一个数组`，必须使用一个循环，每次复制一个元素

- ```c
  int array[10], a;
  for(a = 0; a < 10; a += 1) {
      array[a] = 0;//
  }
  ```

  ```c
  int array[10], *ap;
  for(ap = array; ap < array + 10; ap++) {
      *ap = 0;
  }
  ```

  上面使用下标引用，下面使用指针，区别在于：`下标引用的循环体中，下标表达式需要乘法运算，而指针则不用`。指针比下标更有效率的场合：当你在数组中1次1步（或某个固定的数字）地移动时，与固定数字相乘的运算在编译时完成，所以在运行时所需的指令就少一些。

- 指针效率：

  - `根据某个固定数目的增量在一个数组中移动时`，使用指针变量将比使用下标产生效率更高的代码。当这个增量是1并且机器具有地址自动增量模型时，这点表现得更为突出。
  - 声明为`寄存器变量的指针`通常比位于静态内存和堆栈中的指针效率更高(具体提高的幅度取决于你所使用的机器)。
  - 如果你可以通过测试一些已经初始化并经过调整的内容来判断循环是否应该终止，那么你就不需要使用-一个单独的计数器。
  - 那些必须在运行时求值的表达式较之诸如&array[SIZE]或array+SIZE这样的常量表达式往往代价更高。

- 数组名做函数形参时候，实际传递的是数组第一个元素的地址，根据指针和数组的区别可知，为啥数组形参可以与任何长度的数组匹配

- `数组存储顺序`

  ```c
  int array[3];
  ```

  <img src="C:\Users\HP\Desktop\笔记\images\QQ截图20221127141605.png" style="zoom: 80%;" />

  ```c
  int array[3][3];//每个元素中又含有3个元素
  ```

  <img src="C:\Users\HP\Desktop\笔记\images\QQ截图20221127142250.png" style="zoom:80%;" />

  实线方框表示第1维的3个元素，虚线用于划分第2维的3个元素。按照从左到右的顺序，上面每个元素的下标值分别展示如上。在C中，多维数组的元素存储顺序按照最右边的下标率先变化的原则（行主序）

  ![](C:\Users\HP\Desktop\笔记\images\QQ截图20221127142859.png)

- 指针数组

  ```c
      char const keyword1[][9] = {
          "do",
          "for",
          "if",
          "register",
          "return",
          "switch",
          "while"
      };
  
      char const keyword2[] = {
          "do",
          "for",
          "if",
          "register",
          "return",
          "switch",
          "while",
          NULL//NULL 指针使函数在搜索这个表时，能够检测到表的结束，无需预先知道表的长度
      };
  
  ```

  指针数组本身也要占用空间，但是每个字符串常量占据的内存空间只是它本身的长度，二者的选取取决于指针所占用的空间是否小于每个字符串都存储于固定长度的行所浪费的时间
