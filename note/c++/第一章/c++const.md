#### c++与 c 关于 const 处理不同

```c

#include <stdio.h>
int main(){
    const int n = 10;
    int *p = (int*)&n;  //必须强制类型转换
    *p = 99;  //修改const变量的值
    printf("%d\n", n);
    return 0;
}
```

上述代码，用 gcc 运行输出结果为 99；用 g++运行结果为 10

在 C 语言中，编译器会**先到 m 所在的内存取出一份数据，再将这份数据赋给 n**；

在 C++中，编译器会直接将 10 赋给 n，**没有读取内存的过程**，和 int n = 10;的效果一样。
C++ 中的常量更类似于#define 命令，是一个**值替换**的过程，只不过#define 是在**预处理阶段**替换，而常量是在**编译阶段**替换。

`C++ 对 const 的处理少了读取内存的过程，优点是提高了程序执行效率，缺点是不能反映内存的变化，一旦 const 变量被修改，C++ 就不能取得最新的值。`

【总结】

`C语言对 const 的处理和普通变量一样，会到内存中读取数据；C++ 对 const 的处理更像是编译时期的#define，是一个值替换的过程。`

`全局 const 变量的作用域仍然是当前文件，但是它在其他文件中是不可见的，这和添加了static关键字的效果类似。`

C 和 C++中全局 const 变量的作用域相同，都是当前文件，
不同的是它们的可见范围：C 语言中 const 全局变量的可见范围是整个程序，在其他文件中使用 extern 声明后就可以使用；而 C++中 const 全局变量的可见范围仅限于当前文件，在其他文件中不可见，所以它可以定义在头文件中，多次引入后也不会出错。

C++ 中的 const 变量虽然也会占用内存，也能使用&获取得它的地址，但是在使用时却更像编译时期的#define；#define 也是值替换，可见范围也仅限于当前文件。

很多 C++教程在对比 const 和 #define 的优缺点时提到，#define 定义的常量仅仅是字符串的替换，不会进行类型检查，而 const 定义的常量是有类型的，编译器会进行类型检查，相对来说比 #define 更安全，所以鼓励大家使用 const 代替 #define。
