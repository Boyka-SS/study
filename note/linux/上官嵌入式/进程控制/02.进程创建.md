#### 进程创建

##### 方式一

```c
#include<unistd.h>
pid_t fork(void)
```

**作用**

- 父子进程`同时`执行不同的代码段。
- 一个进程要执行另一个不同的程序。（典型案例 shell）

  **返回值**
  子进程中返回 0，父进程返回子进程的 ID，出错返回-1

  **解释**

fork 函数调用一次，但返回两次。区别在于：`子进程返回的是0，父进程返回的是新子进程的ID`

_返回子进程的 ID 号是为了父进程更好管理子进程（没有一个函数可以使父进程获取所有的其子进程的 ID 号）_

fork 函数创建的是子进程，子进程是父进程的副本，与父进程共享代码段（正文段），但是数据空间，堆栈各自维护

> **写时复制**：父子进程共享数据区和代码区，linux 内核将其（内存）设置为只读权限，只对父子进程想要修改的部分进行备份副本

**案例**

```c
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>

int main(int argc, char** argv) {
  pid_t pid;
  int data = 10;

  while (1) {
    printf("please input your data\n");
    scanf("%d", &data);
    if (data != 1) {
      pid = getpid();
      fork();
      if (pid == getpid()) {
        // 父进程工作区
        printf("this is father's pid : %d\n", getpid());
      } else {
        // 子进程工作区
        printf("this is son's pid : %d\n", getpid());
      }
    }
  }
  return 0;
}

```

##### 方式二

```c
#include <sys/types.h>
#include <unistd.h>

pid_t vfork(void);
```

与 fork 区别

- vfork 直接使用父进程存储空间，不拷贝
- vfork 保证子进程先运行，当子进程调用 exit 退出后，父进程才执行

**案例**

```c

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

int main(int argc, char** argv) {
  pid_t pid;
  int cnt = 0;
  pid = vfork();
  if (pid > 0) {
    while (1) {
      // cnt = 3 cnt!=0，表示vfork的子进程不拷贝父进程
      printf("cnt =  %d\n", cnt);
      printf("parent process's pid is %d\n", getpid());
      sleep(1);
    }
  } else if (pid == 0) {
    while (1) {
      printf("children process's pid is %d\n", getpid());
      sleep(1);
      cnt++;
      if (cnt == 3) {
        exit(1);
      }
    }
  }
  return 0;
}


```
