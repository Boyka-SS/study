#### 父进程等待子进程

**原因**

子进程退出后，父进程确定其是正常还是异常退出，正常退出，子进程任务完成的怎么样（exit 的退出码来确定），

简而言之，_父进程需要通过 wait 获得子进程的退出码来确定子进程的工作状态_

父进程需要确定子进程的工作完成情况，完成程度

**拓展**

子进程由父进程调用 fork 函数生成的，子进程终止时候，会将终止状态返回给父进程

父进程如果不等待子进程退出，在子进程推出之前退出，此时子进程称为**孤儿进程**（没有父进程的进程）

对于父进程已经终止的所有进程，其父进程都会改为 init 进程，称为**init 进程领养**，这就保证了每一个进程都有一个父进程

**子进程终止时会保留少量的信息，父进程可以通过 wait/waitpid 获得这些信息**

在 UINX 术语中，一个已经终止的，但是其父进程没有善后处理（获取终止信息）的进程，称之为**僵尸进程**

**调用 wait/waitpid 函数后的进程 表现情况**

- 子进程还在运行，则阻塞
- 子进程已终止，等待父进程获取其终止状态，则取得该子进程的终止状态返回
- 没有子进程，则报错返回

> wait 和 waitpid 区别在于，前者使得调用者阻塞，后者可以使得调用者不阻塞；waitpid 可以控制要`等待的子进程`

#### wait——获取子进程终止信息

```c
#include<sys/types.h>
#include<sys/wait.h>

pid_t wait(int* status);
pid_t waitpid(pid_t pid,int *status,int options);
```

父进程调用 wait 可以防止子进程变成僵尸进程

**参数**

1. status 整型数指针
   - 非空：子进程退出状态放在它所指向的地址中，整型数指针参数仅是一个子进程退出码的存放容器
   - 空：不关心退出状态
2. pid
   |pid |含义|
   |---|---|
   |pid == -1|等待任意子进程，等效 wait|
   |pid > 0|等待进程 ID 为 pid 的子进程(常用)|
   |pid == 0|等待组 id 等于调用进程组 ID 的任一子进程|
   |pid < -1|等待组 id 等于 pid 绝对值的任一子进程|、

   > waitpid 函数返回等待的子进程 ID，如果指定等待的子进程不存在或者与调用者不在同一进程组的时候会报错
   > wait 在子进程不存在时候会报错

3. options

| 常量           | 含义                                                             |
| -------------- | ---------------------------------------------------------------- |
| WCONTINUED     |                                                                  |
| WNOHANG (常用) | 若 pid 指定的子进程不是立即可用的，则 waitpid 不阻塞，此时返回 0 |
| WUNTRACED      |                                                                  |

**案例**

```c

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

int main(int argc, char** argv) {
  pid_t pid;
  int cnt = 0;
  int status = 10;
  pid = fork();
  if (pid > 0) {
    // wait传入空指针参数表示收集子进程的退出码，但是不在乎
    // 方式一
    // wait(NULL);
     // 方式二(推荐)
    // wait(&status);
    // 方式三
    // waitpid不会阻塞调用者，从而使子进程有可能变为僵尸进程
    waitpid(pid,&status,WNOHANG);
    while (1) {
      printf("cnt =  %d\n", cnt);
      printf("children's status =  %d\n", WEXITSTATUS(status));
      printf("parent process's pid is %d\n", getpid());
      sleep(1);
    }

  } else if (pid == 0) {
    while (1) {
      printf("children process's pid is %d\n", getpid());
      sleep(1);
      cnt++;
      if (cnt == 5) {
        exit(3);
      }
    }
  }
  return 0;
}
```

**检查 wait 或 waitpid 终止状态码的宏**

| 宏            | 说明 |
| ------------- | ---- |
| WIFEXITED     | ---- |
| WIFSIGNALED   | ---- |
| WIFSTOPPED    | ---- |
| WIFCONTINUEED | ---- |
