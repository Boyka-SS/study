#### 一、函数回顾与后置返回类型

```cpp

void func3(int ,int);
void func3(int a,int){}

func3(1,2);
```

函数声明时，可以只有形参类型，没有形参名

函数定义中，形参如果在函数体内用不到的话，则可以不用给形参变量名字，只给其类型

函数的返回类型放到函数名字之前的，这种写法，叫`前置返回类型`

`c++11后，在函数声明和函数定义中，把返回类型放在参数列表之后`

**【语法格式】**

```c++
// 函数名前放auto，表示函数返回类型放到参数列表之后，而放在参数列表之后的返回类型是通过->开始的
auto functionname(int a,...) -> returnType;
auto functionname(int a,...) -> returnType{}
```

#### 二、!!!内联函数

**【语法格式】**

```c++

inline functionname();
```

`**在函数定义之前**，使用 inline 关键字修饰的函数都会成为内联函数`a

内联函数是为了解决调用函数体很小，但调用频繁的函数开销问题

【特点】

1. inline 影响编译器，在编译阶段对 inline 内联函数处理，系统尝试将调用该函数的动作替换为函数本体，依次提升性能
2. inline 只是开发者对编译器的建议，具体是否替换，编译器需要判断。最终决定取决于编译器
3. 内联函数的定义要放在头文件中，这样，调用内联函数的 cpp 文件可以 include 内联函数源代码到本文件中

【缺点】

1. 代码膨胀问题，内联函数函数体尽量少一些
2. 循环分支等代码尽量少出现在内联函数中

【注意】

各个编译器对内联函数处理可能不同

> constexpr 函数可以看成是更严格的一种内联函数
> \#define 宏展开类似于 inline

【函数杂合用法总结】

1. 函数返回类型为 void，表示函数不返回任何类型。但是类型是 void 的函数，可以返回一个 返回类型为 void 的函数
2. 返回指针类型/引用类型的函数，其返回值尽量不要指向函数内部的局部变量，否则主函数会操作非法地址
3. 没有形参的的函数可以保持参数列表为空，或者 void，int myfunc()//int myfunc(void)
4. 未被调用的函数可以先声明后定义
5. 普通函数，只能定义一次（在.cpp 文件中），声明可以多次；内联函数可以定义多次
6. **函数形参使用引用定义，可以使函数对形参的修改传到实参上面**
7. **cpp 中允许函数同名，只需参数列表不同（类型，数量）**

```c++

void funca(){}

void funcb(){
    return funca();
}

// c中习惯使用指针实现形参到实参的改变
// c++中更多用引用
void func(int& a,int& b){}


void fs()
void fs(int a)
void fs(float a)
```

#### 三、const char\*|char const \*|char \* const 区别

`const char*` 与 `char const *`等价，表示指针指向的内容为常量，不可以修改

`char * const ` 表示指向 char 类型的指针指向不能发生改变

> \*前面的修饰符 修饰的是指针指向的内容，\*后面的是修饰指针本身

```c++

const char * p = "love";
// error
*p = 'y';

int i = 100;
// const修饰的引用a，表示a的内容不可以通过a修改
const int &a = i;
i = 100;
a = 500;//error

// 引用是变量的别名，而非常量
int &b = 100;//error
const int &b = 100;//correct
b = 20;//error
```

#### 四、函数形参 const

```c++

// const修饰的引用形参，可以避免函数体内部对形参的无意修改
void func(const int& a,const int &b){}
```
